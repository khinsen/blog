;;;;;
title: Another look at Julia
tags: computational science, scientific computing
date: 2015-06-18 07:56:50
format: html
;;;;;
<p><br>Three years ago, I first looked at the then-very-new language <a href="http://julialang.org/">Julia</a>. <a href="http://khinsen.wordpress.com/2012/04/04/julia-a-new-language-for-scientific-computing/">Back then</a>, I concluded that there were many interesting features, but also regretted too much bad Matlab influence in the array handling.<br></p><br><br><p><br>A hands-on <a href="http://calcul.math.cnrs.fr/spip.php?article259">Julia tutorial</a> in my neighborhood was a good occasion to take another look at this language, which has evolved quite a bit since 2012, and continues to evolve rapidly. The tutorial taught by <a href="http://sistemas.fciencias.unam.mx/~dsanders/">David Sanders</a> was an excellent introduction, and his <a href="https://github.com/dpsanders/hands_on_julia">notebooks</a> should even be good for self-teaching. If you already have some experience in computational science, and are interested in trying Julia out on small practical applications, have a look at them.<br></p><br><br><p><br>The good news is that Julia has much improved over the years, not only by being more complete (in particular in terms of libraries), but also through changes in the language itself. More changes are about to happen with version~0.4 which is currently under development. The changes being discussed include the <a href="http://github.com/JuliaLang/julia/issues/7941">array behavior</a> that I criticized three years ago. It's good to see references to APL in this discussion. I still believe that when it comes to arrays, APL and its successors are an excellent reference. It's also good to see that the Julia developers take the time to improve their language, rather than rushing towards a 1.0 release. <br></p><br><br><p><br>Due to David's tutorial, this time my contact with Julia was much more practical, working on realistic problems. This was a good occasion to appreciate many nice features of the language. Julia has taken many good features from both Lisp and APL, and combined them seamlessly into a language that, in spite of some warts, is overall a pleasure to use. A major aspect of Julia's Lisp heritage is the built-in metaprogramming support. Metaprogramming has always been difficult to grasp, which was clear as well during the tutorial. It isn't obvious at all what kind of problem it helps to solve. But everyone who has used a language with good metaprogramming support doesn't want to go back.<br></p><br><br><p><br>A distinctive feature of Julia is that it occupies a corner of the programming language universe that was almost empty until now. In scientific computing, we have traditionally had two major categories of languages. "Low-level" languages such as Fortran, C, and C++, are close to the machine level: data types reflect those directly handled by today's processors, memory management is explicit and thus left to the programmer. "High-level" languages such as Python or Mathematica present a more abstract view of computing in which resources are managed automatically and the data types and their operations are as close as possible to the mathematical concepts of arithmetic. High-level languages are typically interpreted or JIT-compiled, whereas low-level languages require an explicit compilation step, but this is not so much a feature of the language as of their age and implementation.<br></p><br><br><p><br>Julia is resolutely modern in opting for modern code transformation techniques, in particular under-the-hood JIT compilation, making it both fully compiled and fully interactive. In terms of the more fundamental differences between "low-level" and "high-level", Julia chooses an unconventional approach: automatic memory management, but data types at the machine level.<br></p><br><br><p><br>As an illustration, consider integer handling. Julia's default integers are the same as C's: optimal machine-size signed integers with no overflow checks on arithmetic. The result of <code>10^50</code> is <code>-5376172055173529600</code>, for example. This is the best choice for performance, but it should be clear that it can easily create bugs. Traditional high-level languages use unlimited integers by default, eventually offering machine-size integers as a optimization option for experienced programmers. Julia does have a <code>BigInt</code> type, but using it requires a careful insertion of <code>big(...)</code> in many places. It's there if you absolutely need it, but you are expected to use machine-sized integers most of the time.<br></p><br><br><p><br>As a consequence, Julia is a power tool for experienced scientific programmers who are aware of the traps and the techniques to avoid falling into them. Julia is not a language suitable for beginners or occasional users of scientific programming, because such inexperienced scientists need more of a safety net than Julia provides. Neither is Julia a prototyping language for trying out new ideas, because when concentrating on the science you also need a safety net that protects you from the traps of machine-level abstractions. In Julia, you have to design your own safety net, and you also have to verify that it is strong enough for your needs.<br></p><br><br><p><br>Perhaps the biggest problem with Julia is that this is not obvious at first glance. Julia comes with all the nice interactive tools for rapid development and interactive data analysis, in particular the <a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a> notebook which is basically the same as the now-famous IPython/Jupyter notebook. At a first glance, Julia <b>looks</b> like a traditional high-level language. A strong point of David's Julia tutorial is that it points out right from the start that Julia is different. Whenever a choice must be made between run-time efficiency and simplicity, clarity, or correctness, Julia always chooses efficiency. The least important consequence is surprising error messages that make sense only with a basic understanding of how the compiler works. The worst consequence is that inexperienced users are easily induced to write unsafe code. There are nice testing tools, in particular <a href="https://github.com/JuliaLang/FactCheck.jl">FactCheck</a> which looks very nice, but scientists are notoriously unaware of the need of testing.<br></p><br><br><p><br>The worst design decision I see in Julia is the explicit platform dependence of the language: the default integer size is either 32 or 64 bits, depending on the underlying platform. This default size is used in particular for integer constants. As a consequence, a Julia program does in general not have a single well-defined result, but two distinct results. This means that programs must be tested on two different architectures, which is hard to do even for experienced programmers. Given the ongoing very visible debate about the (non-)reproducibility of computational research, I cannot understand how anyone can make such a decision today. Of course I do understand the performance advantage that results from this choice, but this clearly goes to far for my taste. If I ever use Julia for my research, I'll start each source code file with <code>@assert WORD_SIZE==64</code> just to make sure that everyone knows what kind of machine I tested my code on.<br></p><br><br><p><br>As for the surprising but not dangerous features that can probably only be explained by convenience for the compiler, there is first of all the impossibility to redefine a data type without clearing the workspace first - and that means losing your whole session. It's a bit of a pain for interactive development, in particular in <a href="https://github.com/JuliaLang/IJulia.jl">IJulia</a> notebooks. Another oddity is the <code>const</code> declaration, which makes a variable to which you can assign new values as often as you like, as long as the type remains the same. It's more a typed variable declaration than the constant suggested by the name.<br></p><br><br><p><br>Finally, there is another point where I think the design for speed has gone too far. The choice of machine-size integers turns into something completely useless (in my opinion) when it comes to rational arithmetic. Julia lets you create fractions by writing <code>3//2</code> etc., but the result is a fraction whose nominator and denominator are machine-size integers. Rational arithmetic has the well-known performance and memory problem of denominators growing with each additional operation. With machine-size integers, rational arithmetic <a href="https://github.com/JuliaLang/julia/issues/11736">rapidly crashes or returns wrong results</a>. Given that the primary application of rationals is unlimited precision arithmetic, I don't see a practical use for anything but <code>Rational{BigInt}</code>.<br></p><br><br><p><br>In the end, Julia leaves me with a feeling of a lost opportunity. My ideal software development environment for computational science would support the whole life cycle of computational methods, starting from prototyping and ending with platform-specific optimizations. As code is progressively optimized based on profiling information, each version would be used as a reference to test the next optimization level. In terms of fundamental language design, Julia seems to have everything required for such an approach. However, the default choice of fast-and-unsafe operations almost forces programmers into premature optimization. Like in the traditional high-/low-level language world, computational science will require two distinct languages, a safe and a fast one.<br></p><br>
