;;;;;
title: The future of the Scientific Python ecosystem
tags: computational science, programming, python
date: 2015-07-16 10:13:27
format: html
;;;;;
<p><br>SciPy 2015 is over, meaning that many non-participants like myself are now busy catching up with what happened by watching <a href="https://www.youtube.com/playlist?list=PLYx7XA2nY5Gcpabmu61kKcToLz0FapmHu">the videos</a>. Today's dose for me was Jake VanderPlas' <a href="https://www.youtube.com/watch?v=5GlNDD7qbP4&amp;list=PLYx7XA2nY5Gcpabmu61kKcToLz0FapmHu&amp;index=3">keynote</a> entitled "State of the Tools". It's about the history, current state, and potential future of what is now generally known as the Scientific Python ecosystem: the large number of libraries and tools written in or for Python that scientists from many disciplines use to get their day-to-day computational work done.<br></p><br><br><p><br>History is done, the present status is a fact, but the future is open to both speculation and planning, so that's what I find most interesting in Jake's keynote. What struck me is that everything he discussed was about paying back technical debt: refactoring the core libraries, fixing compatibility problems, removing technical obstacles to installation and use of various tools. In fact, 20 years after Python showed up in scientific computing, the ecoystem is in a state that is typical for software projects of that age: a bit of a mess. The future work outlined by Jake would help to make it less of a mess, and I hope that something like this will actually happen. The big question mark for me is how this can be funded, given that it is "only" maintenance work, producing nothing fundamentally new. Fortunately there are people much better than me at thinking about funding, for example everyone involved in the <a href="http://numfocus.org/">NumFOCUS</a> foundation.<br></p><br><br><p><br>Jake's approach to outlining the future is basically "how can we fix known problems and introduce some obvious improvements" (but please do watch the video to get the full story!). What I'd like to present here is an alternate approach: imagine an ideal scientific computing environment in 2015, and try to approximate it by an evolution of the current SciPy ecosystem while retaining a sane level of backwards compatibility. Think of it as the equivalent of Python 3 at the level of the core of the scientific ecosystem.<br></p><br><br><p><br>One aspect that has changed quite a bit over 20 years is the interaction between Python and low-level code. Back then, Python had an excellent C interface, which also worked well for Fortran 77 code, and the ease of wrapping C and Fortran libraries was one of the major reasons for Python's success in scientific computing. We have seen a few generations of wrapper code generators, starting with <a href="http://www.swig.org/">SWIG</a>, and the idea of a hybrid language called <a href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/">Pyrex</a> that was the ancestor of today's <a href="http://cython.org/">Cython</a>. LLVM has been a major game changer, because it permits low-level code to be generated and compiled on-the-fly, without explicitly generating wrappers and compiling code. While wrapping C/C++/Fortran libraries still remains important, the equally important task of writing low-level code for performance can be handled much better with such tools. <a href="http://numba.pydata.org/">Numba</a> is perhaps the best-known LLVM-based code generator in the Python world, providing JIT compilation for a language that is very similar to a subset of Python. But Numba is also an example of the mindset that has led to the current mess: take the existing ecosystem as given, and add a piece to it that solves a specific problem.<br></p><br><br><p><br>So how would one approach the high-/low-level interface today, having gained experience with LLVM and PyPy? Some claim that the distinction doesn't make sense any more. The authors of the <a href="http://julialang.org/">Julia</a> language, for example, <a href="https://github.com/stevengj/julia-mit">claim</a> that it "avoids the two-language problem". However, as I have <a href="https://khinsen.wordpress.com/2015/06/18/another-look-at-julia/">pointed out on this blog</a>, Julia is fundamentally a performance-oriented low-level language, in spite of having two features, interactivity and automatic memory management, that are traditionally associated with high-level languages. By the way, I don't believe the idea of a both-high-and-low-level language is worth pursuing for scientific computing. The closest realization of that idea is Common Lisp, which is as high-level as Python, perhaps more so, and also as low-level as Julia, but at the cost of being a very complex language with a very steep learning curve, especially for mastering the low-level aspects. Having two clearly distinct language levels makes it possible to keep both of them manageable, and the separation line serves as a clear warning sign to scientists, who should not attempt to cross it without first acquiring some serious knowledge about software development.<br></p><br><br><p><br>The model to follow, in my opinion, is the one of <a href="http://lush.sourceforge.net/">Lush</a> and <a href="http://terralang.org/">Terra</a>. They embed a low-level language into a high-level language in such a way that the low-level code is a data structure at the high level. You can use literals for this data structure and get the equivalent of Numba. But you can also write code generators that specialize low-level code for a given problem. Specialization allows both optimization and simplification, both of which are desirable. The low-level language would have arrays as a primitive data structure, and both NumPy and Pandas, or evolutions such as <a href="https://xray.readthedocs.org/">xray</a>, would become shallow Python APIs to such low-level array functionality. I think this is much more powerful than today's Numba building on NumPy. Moreover, wrapper generators become simple plain Python code, making the construction of interfaces to complex libraries (think of <a href="http://www.h5py.org/">h5py</a>) much easier than it is today. Think of it as <a href="https://docs.python.org/3.5/library/ctypes.html">ctypes</a> on steroids. For more examples of what one could do with such a system, look at <a href="http://docs.julialang.org/en/release-0.3/manual/metaprogramming/">metaprogramming in Julia</a>, which is exactly the same idea.<br></p><br><br><p><br>Another aspect that Jake talks about in some detail is visualization. There again, two decades of code written by people scratching their own itches has led to a mess of different libraries with a lot of overlap and no clear distinctive features. For cleaning it up, I propose the same approach: what are the needs and the available technologies for scientific visualization in 2015? We clearly want to profit from all the Web-based technologies, both for portability (think of mobile platforms) and for integration with <a href="http://jupyter.org/">Jupyter</a> notebooks. But we also need to be able to integrate visualization into GUI applications. From the API point of view, we need something simple for simple plots (<a href="https://toyplot.readthedocs.org/">Toyplot</a> looks promising), but also more sophisticad APIs for high-volume data visualization. The main barrier to overcome, in my opinion, is the current dominance of Matplotlib, which isn't particularly good in any of the categories I have outlined. Personally, I don't believe that any evolution of Matplotlib can lead to something pleasant to use, but I'd of course be happy to be proven wrong.<br></p><br><br><p><br>Perhaps the nastiest problem that Jake addresses is packaging. He seems to believe that <a href="http://www.continuum.io/blog/conda">conda</a> is the solution, but I don't quite agree with that. Unless I missed some recent evolutions, a Python package prepared for installation through conda can only be used easily with a Python distribution built on conda as well. And that means Anaconda, because it's the only one. Since Anaconda is not Open Source, there is no way one can build a Python installation from scratch using conda. Of course, Anaconda is perfectly fine for many users. But if you need something that Anaconda does not provide, you may not be able to add it yourself. On the Mac, for example, I cannot compile C extensions compatible with Anaconda, because Mac Anaconda is built for compatibility with ancient OSX versions that are not supported by a standard XCode installation. Presumably that can be fixed, but I suspect that would be a major headache. And then, how about platforms unsupported by Anaconda?<br></p><br><br><p><br>Unfortunately I will have to leave this at the rant level, because I have no better proposition to make. Packaging has always been a mess, and will likely remain a mess, because the underlying platforms on which Python builds are already a mess. Unfortunately, it's becoming more and more of a problem as scientific Python packages grow in size and features. It's gotten to the point where I am not motivated to figure out how to install <a href="http://www.ill.eu/fr/instruments-support/computing-for-science/cs-software/all-software/nmoldyn/">the latest version</a> of <a href="http://dirac.cnrs-orleans.fr/plone/software/nmoldyn/nmoldyn-2/">nMOLDYN</a> on my Mac, although I am a co-author of that program. The previous version is good enough for my own needs, and much simpler to install though already a bit tricky. That's how you get to love the command line&#x2026; in 2015.<br></p><br>
