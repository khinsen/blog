;;;;;
title: The Nix package manager in computational science
tags: reproducible research
date: 2012-05-14 16:08:05
format: html
;;;;;
<p>In an <a href="http://khinsen.wordpress.com/2012/04/10/unifying-version-control-and-dependency-management-for-reproducible-research/">earlier post</a>, I mentioned the <a href="http://nixos.org/">Nix package management system</a> as a candidate for ensuring reproducibility in computational science. What distinguishes Nix from the better known package managers (Debian, RPM, ...) is that it permits the installation of different versions of the same package in parallel, with a dependency tracking system that refers to a precise version of everything, including the versions of the development tools (compilers, ...) that were used to build the libraries and executables. Nix thus remembers for each package the complete details of how it can be reconstructed, which is what we would like to see for ensuring reproducibility.<br><br><p>There are, however, two caveats. First of all, Nix was designed for software installation management and not for computation. While in principle one could define the results (figures, tables, datasets) of some computation as a Nix package and perform the computation by installing the package, such an approach is quite cumbersome with the Nix support tools designed with a different task in mind. However, computation-specific support tools would probably suffice to fix this. Second, while the design of Nix looks quite sound, it is a young project with much less manpower behind it than the big package managers of the Linux world. This means there are fewer package definitions and they are overall less reliable. For example, I haven't yet managed to install my research computing environment (Python, NumPy, matplotlib, plus a few more packages) using Nix under MacOS X, because some packages simply fail to build. Again this is not an insurmountable problem, but it requires some serious effort to fix.<br><br><p>The Nix documentation is pretty good at describing how to use the package manager and the collection of package definitions for Linux and MacOS X named Nixpkgs. It is not so good at giving a basic understanding of how Nix works, which becomes important when you want to use it for something else than traditional package management. The following overview is the result of my own explorations of Nix. I am not a Nix authority, so be warned that there may be mistakes or misunderstandings.<br><br><p>At the heart of Nix is the "Nix store", a central database where everything managed by Nix is kept. Its default location is <code>/nix/store</code> and if you look at it you see an overwhelmingly long list of crypic filenames. Let's zoom in on something to see what's going on. Here is what <code>ls -l /nix/store/*zlib*</code> shows on my machine:<br><pre><br>-r--r--r-- 1 hinsen staff 1000 Jan  1  1970<br> /nix/store/12vkkhs36xffzpqjaaa3vqhqv2yc97vs-zlib-1.2.6.drv<br>-r--r--r-- 1 hinsen staff 1181 Jan  1  1970<br> /nix/store/gymcn145ihhmymm6yk2wxqfd49s5dzdq-zlib-1.2.6.drv<br>dr-xr-xr-x 5 hinsen staff  170 Jan  1  1970<br> /nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6<br>-r--r--r-- 1 hinsen staff 1000 Jan  1  1970<br> /nix/store/sj8l48kfc40wh8adb5pa843lwy38hskb-zlib-1.2.6.drv<br>-r--r--r-- 1 hinsen staff 1686 Jan  1  1970<br> /nix/store/xpm2xja2zv5agmdzgi362jqd5xx9ny10-zlib-1.2.6.tar.gz.drv<br></pre><br>The single directory in that list actually contains the <code>zlib</code> installation in the familiar Unix file layout that you find under <code>/usr</code> or <code>/usr/local</code>:<br><pre><br>~&gt; ls -R /nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6<br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6:<br>include  lib  share<br><br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6/include:<br>zconf.h  zlib.h<br><br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6/lib:<br>libz.1.2.6.dylib  libz.1.dylib	libz.a	libz.dylib  pkgconfig<br><br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6/lib/pkgconfig:<br>zlib.pc<br><br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6/share:<br>man<br><br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6/share/man:<br>man3<br><br>/nix/store/mrdqnzzr80rkfnm59q6aywdba6776f66-zlib-1.2.6/share/man/man3:<br>zlib.3.gz<br></pre><br>Note that it contains just <code>zlib</code>, and nothing else, in particular not <code>zlib</code>'s dependencies. Each library or application has its own directory in the Nix store.<br><br><p>Next, let's look at all the other files, those with the extension <code>.drv</code> (for "derivation", a Nix term for any artefact derived from human-provided input). There are three files that end in <code>zlib-1.2.6.drv</code> and one that ends in <code>zlib-1.2.6.tar.gz.drv</code>. Let's look at the contents of the last one first. I have made it more readable by adding whitespace:<br><pre><br>Derive(<br>   [("out",<br>     "/nix/store/s9qgdh7g22nx433y3lk62igm5zh48dxj-zlib-1.2.6.tar.gz",<br>     "sha256",<br>     "21235e08552e6feba09ea5e8d750805b3391c62fb81c71a235c0044dc7a8a61b")],<br>   [("/nix/store/lhc0qhfdrw32rj1z7s5p90nbjfnkydhb-stdenv.drv",<br>     ["out"]),<br>    ("/nix/store/pawry9l3415kwfbfh4zrhgnynwfb10bs-mirrors-list.drv",<br>     ["out"])],<br><br>   ["/nix/store/01w11lngp8s4lxllyr6xbmjfyrfkrn43-builder.sh"],<br><br>   "x86_64-darwin",<br>   "/bin/bash",<br>   ["-e",<br>    "/nix/store/01w11lngp8s4lxllyr6xbmjfyrfkrn43-builder.sh"],<br><br>   [("buildInputs",""),<br>    ("buildNativeInputs",""),<br>    ("builder","/bin/bash"),<br>    ("id",""),<br>    ("impureEnvVars","http_proxy https_proxy ftp_proxy all_proxy no_proxy NIX_CURL_FLAGS NIX_HASHED_MIRRORS NIX_MIRRORS_apache NIX_MIRRORS_bitlbee NIX_MIRRORS_cpan NIX_MIRRORS_debian NIX_MIRRORS_fedora NIX_MIRRORS_gcc NIX_MIRRORS_gentoo NIX_MIRRORS_gnome NIX_MIRRORS_gnu NIX_MIRRORS_gnupg NIX_MIRRORS_hashedMirrors NIX_MIRRORS_imagemagick NIX_MIRRORS_kde NIX_MIRRORS_kernel NIX_MIRRORS_metalab NIX_MIRRORS_oldsuse NIX_MIRRORS_opensuse NIX_MIRRORS_postgresql NIX_MIRRORS_savannah NIX_MIRRORS_sf NIX_MIRRORS_sourceforge NIX_MIRRORS_ubuntu NIX_MIRRORS_xorg"),<br>    ("mirrorsFile","/nix/store/mmk41rbja1fvclbr7ghirzcigxlzl6f0-mirrors-list"),<br>    ("name","zlib-1.2.6.tar.gz"),<br>    ("out","/nix/store/s9qgdh7g22nx433y3lk62igm5zh48dxj-zlib-1.2.6.tar.gz"),<br>    ("outputHash","06x6m33ls1606ni7275q5z392csvh18dgs55kshfnvrfal45w8r1"),<br>    ("outputHashAlgo","sha256"),<br>    ("preferHashedMirrors","1"),<br>    ("preferLocalBuild","1"),<br>    ("propagatedBuildInputs",""),<br>    ("propagatedBuildNativeInputs",""),<br>    ("showURLs",""),<br>    ("stdenv","/nix/store/9fnvs0bvhrszazham5cnl13h52hvm1rk-stdenv"),<br>    ("system","x86_64-darwin"),<br>    ("urls","http://www.zlib.net/zlib-1.2.6.tar.gz mirror://sourceforge/libpng/zlib/1.2.6/zlib-1.2.6.tar.gz")])<br></pre><br>If that looks like a computational expression in a programming language, that's because it is. Don't worry, it's not something you are expected to write yourself, these expressions are created from the package definitions written in a more user-friendly syntax called "Nix expressions", which is very well documneted in the Nix documentation.. The expression shown above defines how to make (or "realise" in Nix jargon) the derivation <code>/nix/store/s9qgdh7g22nx433y3lk62igm5zh48dxj-zlib-1.2.6.tar.gz</code>, which is a rather simple one because the file is simply downloaded and verified for a known checksum. But even such a simple derivation has dependencies: the "standard environment" <code>stdenv</code> and the list of download mirror sites, <code>mirrors-list</code>.<br><br><p>It's time to say something about those funny 32-character prefixes in all the file names in the Nix store. You may have noticed that the <code>zlib</code> file list above contains two entries for <code>zlib-1.2.6.drv</code> that are identical except for this prefix. It looks as if the prefix is there to distinguish things that would otherwise be identical. This is true, and the information encoded in the prefix (which is a hash code) is the complete set of dependencies. The two zlib derivations differ in the version of the standard environment they were built with. I have both of these in my Nix store because I have played around with different releases of Nixpkgs. Nix really tries to keep track of every single dependency, including the exact versions of the various tools (mainly compilers) that were used in building a binary installation. That means you can keep lots of different versions of every single item on your system at the same time, and trace back exactly how they were built. You can also send a copy of the relevant derivation files (those with the <code>.drv</code> extension) to someone else, who can reproduce the exact same environment by "realising" those derivations again.<br><br><p>With so many zlibs floating around, which one does Nix use when you ask it to install some application that uses zlib? The one you specify. When some application requires zlib as a dependency, you have to tell Nix exactly which zlib derivation you want to be used. You don't normally do this manually for every single build (though you could), you'd rather use a coherent set of package definitions (such as Nixpkgs) that specifies all the interdependencies among hundreds of packages. The package definitions take the form of "Nix expressions", which are written in a language specifically designed for this purpose. Files containing Nix expressions have the extension <code>.nix</code>. Since the language is rather well documented in the Nix manual, I won't say any more about it here. A good starting point is to explore Nixpkgs. It helps to know that the central file is <code>pkgs/top-level/all-packages.nix</code>. This file imports the definitions of individual packages from their respective packages and makes a consistent package collection from them. When you build a particular derivation from Nixpkgs, only the packages listed explicitly as its dependencies are available in the build environment that is set up specifically for this build operation. No "default library" (such as <code>/usr/lib</code>) is used at all.<br><br><p>There is one more layer to Nix, whose role is twofold: making it convenient for users to work with programs installed through Nix, and pemitting to remove packages that were installed but are no longer needed.<br>Let's start with the second aspect because it is the simpler one: packages can be removed as soon as nobody needs them any more. This requires a way to figure out which packages are still needed. Obviously the packages that some user on the system wants to access are "needed", and that's why cleanup is related to user profiles which I will cover in a minute. The remaining needed packages are the dependencies of other needed packages. So once we know the packages that all users put together request to use, we can figure out which packages can safely be deleted. This clean-up operation is called "garbage collection" and handled by the command <code>nix-store --gc</code>.<br><br><p>Nix user environments are managed using the command <code>nix-env</code>, and if you don't care about <i>how</i> Nix works, that command is the only one you may ever need. Each user has his/her own environment, of course, which consists mainly of a directory named <code>$HOME/.nix-profile</code>. That directory contains subdirectories called <code>bin</code>, <code>lib</code>, <code>man</code> etc. whose names should sound familiar. They contain nothing but symbolic links into the Nix store. These links define which package the user actually accesses, by putting <code>$HOME/.nix-profile/bin</code> on th3 <code>PATH</code> environment variable. When you use <code>nix-env</code> to install a package, Nix builds it and puts it into the Nix store (unless it's already there), and then creates symbolic links in your Nix profile, which may replace links to some different version of a package. It is important to understand that your use profile never enters into the build process of any Nix derivation. Your profile is exclusively for your own use and has no impact on Nix package management other than protecting the packages you use from being removed during garbage collection.<br><br><p>So far for a first report on my exploration of Nix. I will continue trying to get my computational environment built with Nix, so that I can start to explore how to use it for reproducible computations. Watch this space for news.<br><br><p>PS: After I published this post initially, the friendly people on the Nix mailing list pointed out some additional material for learning about Nix. First of all, there is <a href="http://www.st.ewi.tudelft.nl/~dolstra/pubs/phd-thesis.pdf">Eelco Dolstra's thesis</a> entitled "The Purely Functional Software Deployment Model", which is what you should read if you really want to know <em>everything</em> about Nix. There's also <a href="http://sandervanderburg.blogspot.com/">Sander van der Burg's blog</a> which has some very detailed posts about Nix and what it can be used for. You could start with <a>this</a> introduction.
