;;;;;
title: Julia: a new language for scientific computing
tags: programming
date: 2012-04-04 07:18:48
format: html
;;;;;
<p>New programming languages are probably invented every day, and even those that get developed and published are too numerous to mention. New programming languages developed specifically for science and engineering are very rare, however, and that's why such a rare event deserves some publicity. A while ago, I saw an announcement for <a href="http://julialang.org/">Julia</a>, which announces itself as "a fresh approach to technical computing". I couldn't resist the temptation to download, install, and test-drive it. Here are my first impressions.<br><br><p>The languages used today for scientific computing can be grouped into four categories:<br><ul><br><li> Traditional compiled languages optimized for number crunching. The big player in this category is of course Fortran, but some recent languages such as X10, Chapel, or Fortress are trying to challenge it.</li><br><br><li> Rapid-development domain-specific languages, usually interpreted. Well-known examples are Matlab an R.</li><br><br><li> General-purpose statically compiled languages with libraries for scientific computing. C and C++ come to mind immediately.</li><br><br><li> General-purpose dynamic languages with libraries for scientific computing. The number one here is Python with its vast library ecosystem.</li><br></ul><br><br><p>What sets Julia apart is that it sits somewhere between the first two categories. It's compiled, but fully interactive, there is no separate compilation phase. It is statically typed, allowing for efficient compilation, but also has the default type "Any" that makes it work just like dynamically typed languages in the absence of type declarations. Type infererence makes the mix even better. If that sounds like the best of both worlds, it actually is. It has been made possible by modern code transformation techniques that don't really fit into the traditional categories of "compilers" and "interpreters". Like many other recent languages and language implementations, Julia uses <a href="http://llvm.org/">LLVM</a> as its infrastructure for these code transformations.<br><br><p>Julia has a well-designed type system with a clear orientation towards maths and number crunching: there is support for complex numbers, and first-class array support. What may seem surprising is that Julia is not object-oriented. This is neither an oversight nor a nostalgic return to the days of Fortran 77, but a clear design decision. Julia has type hierarchies and function polymorphism with dispatch on the types of all arguments. For scientific applications (and arguably for some others), this is more useful than OO style method dispatch on a single value.<br><br><p>Another unusual feature of Julia is a metaprogramming system that is very similar to Lisp macros, although it is slightly more complicated by the fact that Julia has a traditional syntax layer, whereas Lisp represents code by data structures.<br><br><p>So far for a summary of the language. The real question is: does it live up to its promises? Before I try to answer that question, I would like to point out that Julia is a young language that is still in flux and for now has almost no development tool support. For many real-life problems, there is no really good solution at the moment but it is clear that a good solution can be provided, it just needs to be done. What I am trying to evaluate is not if Julia is ready for real-life use (it is not), but whether there are any fundamental design problems.<br><br><p>The first question I asked myself is how well Julia can handle non-scientific applications. I just happened to see <a href="http://www.johndcook.com/blog/2012/04/02/why-scipy/">a blog post by John D. Cook</a> explaining why it's preferable to write math in a general-purpose language than to write non-math in a math language. My experience is exactly the same, and that's why I have adopted Python for most of my scientific programming. The point is that any non-trivial program sooner or later requires solving non-math problems (I/O, Web publishing, GUIs, ...). If you use a general-purpose language, you can usually just pick a suitable library and go ahead. With math-only languages such as Matlab, your options are limited, with interfacing to C code sometimes being the only way out.<br><br><p>So is it feasible to write Web servers or GUI libraries in Julia? I would say yes. All the features of general-purpose languages are there or under consideration (I am thinking in particular of namespaces there). With the exception of systems programming (device drivers and the like), pretty much every programming problem can be solved in Julia with no more effort than in most other languages. The real question is if it will happen. Julia is clearly aimed at scientists and engineers. It is probably good enough for doing Web development, but it has nothing to offer for Web developers compared to well-established languages. Will scientists and engineers develop their own Web servers in Julia? Will Web developers adopt Julia? I don't know.<br><br><p>A somewhat related question is that of interfacing to other languages. That's a quick way to make lots of existing code available. Julia has a C interface (which clearly needs better tool support, but I am confident that it will come), which can be used for other sufficiently C-like languages. It is not clear what effort will be required to interface Julia with languages like Python or Ruby. I don't see why it couldn't be done, but I can't say yet whether the result will be pleasant to work with.<br><br><p>The second question I explored is how well Julia is suited to my application domain, which is molecular simulations and the analysis of experimental data. Doing molecular simulation in Julia looks perfectly feasible, although I didn't really implement any non-trivial algorithm yet. What I concentrated on first is data analysis, because that's where I could profit most from Julia's advantages. The kinds of data I mainly deal with are (1) time series and frequency spectra and (2) volumetric data. For time series, Julia works just fine. My biggest stumbling block so far has been volumetric data.<br><br><p>Volumetric data is usually stored in a 3-dimensional array where each axis corresponds to one spatial dimension. Typical operations on such data are interpolation, selection of a plane (2-d subarray) or line (1-d subarray), element-wise multiplication of volume, plane, or line arrays, and sums over selected regions of the data. Using the general-purpose array systems I am familiar with (languages such as APL, libraries such as NumPy for Python), all of this is easy to handle.<br><br><p>Julia's arrays are different, however. Apparently the developers' priority was to make the transition to Julia easy for people coming from Matlab. Matlab is based on the principle that "everything is a matrix", i.e. a two-dimensional array-like data structure. Matlab vectors come on two flavors, row and column vectors, which are actually matrices with a single row or column, respectively. Matlab scalars are considered 1x1 matrices. Julia is different because it has arrays of arbitrary dimension. However, array literals are made to resemble Matlab literals, and array operations are designed to behave as similar as possible to Matlab operations, in particular for linear algebra functions. In Julia, as in Matlab, matrix multiplication is considered more fundamental than elementwise multiplication of two arrays.<br><br><p>For someone used to arrays that are nothing more than data structures, the result looks a bit messy. Here are some examples:<br><br><pre><br>julia&gt; a = [1; 2]<br>[1, 2]<br><br>julia&gt; size(a)<br>(2,)<br><br>julia&gt; size(transpose(a))<br>(1,2)<br><br>julia&gt; size(transpose(transpose(a)))<br>(2,1)<br></pre><br>I'd expect that the transpose of the transpose is equal to the original array, but that's not the case. But what does transpose do to a 3d array? Let's see:<br><pre><br>julia&gt; a = [x+y+z | x=1:4, y=1:2, z = 1:3]<br>4x2x3 Int64 Array:<br>...<br><br>ulia&gt; transpose(a)<br>no method transpose(Array{Int64,3},)<br> in method_missing at base.jl:60<br></pre><br>OK, so it seems this was not considered important enough, but of course that can be fixed.<br><br><p>Next comes indexing:<br><pre><br>julia&gt; a = [1 2; 3 4]<br>2x2 Int64 Array:<br> 1  2<br> 3  4<br><br>julia&gt; size(a)<br>(2,2)<br><br>julia&gt; size(a[1, :])<br>(1,2)<br><br>julia&gt; size(a[:, 1])<br>(2,1)<br><br>julia&gt; size(a[1, 1])<br>()<br></pre><br>Indexing a 2-d array with a single number (all other indices being the all-inclusive range <code>:</code>) yields a 2-d array. Indexing with two number indices yields a scalar. So how do I extract a 1-d array? This generalizes to higher dimensions: if the number of number indices is equal to the rank of the array, the result is a scalar, otherwise it's an array of the same rank as the original.<br><br><p>Array literals aren't that frequent in practice, but they are used a lot in development, for quickly testing functions. Here are some experiments:<br><pre><br>julia&gt; size([1 2])<br>(1,2)<br><br>julia&gt; size([1; 2])<br>(2,)<br><br>julia&gt; size([[1;2] ; [3;4]])<br>(4,)<br><br>julia&gt; size([[1;2] [3;4]])<br>(2,2)<br><br>julia&gt; size([[1 2] [3 4]])<br>(1,4)<br><br>julia&gt; size([[[1 2] [3 4]] [[5 6] [7 8]]])<br>(1,8)<br></pre><br>Can you guess the rules? Once you have them (or looked them up in the Julia manual), can you figure out how to write a 3-d array literal? I suspect it's not possible.<br><br><p>Next, summing up array elements:<br><pre><br>julia&gt; sum([1; 2])<br>3<br><br>julia&gt; sum([1 2; 3 4])<br>10<br></pre><br>Apparently <code>sum</code> doesn't care about the shape of my array, it always sums the individual elements. Then how do I do a sum over all the rows?<br><br><p>I have tried to convert some of my basic data manipulation code from Python/NumPy to Julia, but found that I always spent most of the time fighting against the built-in array operations, which are clearly not made for my kind of application. In some cases a change of attitude may be sufficient. It seems natural to me that a plane extracted from volumetric data should be a 2-d array, but maybe if I decide that should be a 3-d array of "thickness" 1, everything will be easy.<br><br><p>I haven't tried yet, because I know there are cases that cannot be dealt with in that way. Suppose I have a time series of volumetric data that I store in a 4-d array. Obviously I want to be able to apply functions written for static volumetric data (i.e. 3-d arrays) to an element of such a time series. Which means I <i>do</i> need a way to extract a 3-d array out of a 4-d array.<br><br><p>I hope that what I need is there and I just didn't find it yet. Any suggestions are welcome. For now, I must conclude that test-driving Julia is a frustrating experience: the language holds so many promises, but fails for my needs due to superficial but practically very important problems.<br>
