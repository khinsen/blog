;;;;;
title: Static typing and code clutter
tags: programming
date: 2009-05-12 12:46:53
format: html
;;;;;
Among the many characteristics that distinguish programming languages, static vs. dynamic typing is one of the most debated ones. The main advantages claimed by the advocates of static typing are that compile-time type checks make code more robust and that static typing allows a compiler to do better optimizations. The dynamic programming camp points out the simplicity and flexibility of a language that requires no type declaration and that permits a piece of code to handle data objects defined well after it was written. Both sides are right and the choice is ultimately one of personal preference.<br><br>I have used various programming languages over the years, including both statically typed and dynamically typed ones. But when given a choice, I have always preferred dynamic typing. Since 1995, my main programming language has been <a href="http://www.python.org/">Python</a>, and more recently I have started to use <a href="http://clojure.org/">Clojure</a>. One of the reasons for this preference is something that I have never seen expressed before: static typing often adds visual clutter to the code that makes it harder to read.<br><br>An important property of any non-trivial computer program is its clarity to human readers. Both verification of a program's correctness and the overall utility of a piece of code in a context of changing requirements depend on this. Well-written specifications and unit tests help as well, but if you want my advice on the quality of a piece of code, or if you want my help with modifying it, my judgement will mostly be based on its clarity. If it's an effort to understand what's going on, I wouldn't want to work with it.<br><br>This criterion for code quality immediately translates into a criterion for programming languages: they should be able to express as many concepts of software engineering as possible in a direct, explicit way and without imposing any clutter or obfuscation. Static type systems often get in the way, either by imposing clutter or by encouraging a less clear programming style.<br><br>In my examples, I will use the languages <a href="http://www.haskell.org/">Haskell</a> (static typing) and <a href="http://clojure.org/">Clojure</a> (dynamic typing) for illustration. Haskell has one of the best type systems available at the moment, so if Haskell can't avoid the problems that I point out, it is likely that no other current language will do a better job. Clojure is a good comparison because like  Haskell it is designed for a functional programming style. Of course, it also helps that I am reasonably familiar with both languages.<br><br><strong>Example 1: abstract data types</strong><br><br>The idea behind abstract data types is that the concrete representation of some data structure should be hidden from client code, which accesses the data structure only through a set of interface functions. Let's look at how this is typically implemented in Haskell, using the <a href="http://web.engr.oregonstate.edu/~erwig/pfp/">PFP library</a> for probabilistic programming as the example (just because I happen to know it, many other libraries could serve the same purpose). In PFP, a probability distribution is represented by an abstract data type <code>Dist a</code> defined as<br><pre>newtype Dist a = D {unD :: [(a,ProbRep)]}</pre><br>This says that internally, <code>Dist</code> is a list of <code>(a, ProbRep)</code> pairs. The single constructor <code>D</code> converts such a list to the abstract data type <code>Dist</code>, whereas <code>unD</code> does the inverse: it makes the contents of a <code>Dist</code> value accessible for inspection.<br><br>The problem with this is that all of the implementation code for PFP is littered with <code>D</code> and <code>unD</code>, although they don't do anything and add nothing to the clarity of the code. They are there only to make sure that the signature of the functions contains the abstract type <code>Dist a</code> instead of the internal representation <code>[(a,ProbRep)]</code>. For the reader of the PFP code trying to understand how it works, this is clutter. There are also a couple of functions that exist only for dealing with the artificial distinction between <code>Dist a</code> and <code>[(a,ProbRep)]</code>, for example<br><pre>sizeD :: Dist a -&gt; Int<br>sizeD = length . unD</pre><br>which replaces the list function <code>length</code> (familiar to every Haskell programmer) by a special version whose purpose the reader has to remember.<br><br>A Clojure library that is essentially equivalent to PFP (look at the <a href="http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/probabilities/finite_distributions.clj">source code</a>) is much shorter, and in my opinion much clearer. It represents a probability distribution by a map (known in other languages as a dictionary or an associative array) and directly uses Clojure's map operations to work on it. No visual overhead, no clutter. Of course, as static typing advocates would be quick to point out, no protection of the internal representation either: client code could directly manipulate the maps used to represent distributions, potentially creating maps that are not valid probability distributions. I have never run into such a problem in 15 years of using dynamically typed languages, but in principle it is possible.<br><br>It would be possible to avoid the code obfuscation due to abstract data types by recognizing that abstract data types are an interface issue and not a type issue. A language could provide an explicit declaration of an interface for a module where the function signatures would be given with the abstract data type, even though the concrete representation is used in the implementations. The compiler could verify the coherence of everything. But I haven't seen anything like this in any statically typed language.<br><br>Note also that something very similar could be implemented in Clojure: A couple of macros would provide wrappers around the exported functions that add type verification at runtime. However, this says more about the advantage of having a powerful macro system than about the advantages of dynamic typing.<br><br><strong>Example 2: monads</strong><br><br>A monad is package consisting of a data structure (or, more precisely, certain properties that a data structure must have) and two functions <code>bind</code> and <code>result</code>. A subclass of monads also has a special value called <code>zero</code> and a subclass of this subclass has one more function called <code>plus</code>. All these definitions must obey certain rules to make a valid monad.<br><br>In Haskell, there is a typeclass <code>Monad</code> that defines <code>bind</code> (called <code>&gt;&gt;=</code>) and result (called <code>return</code>), and another typeclass <code>MonadPlus</code> that defines <code>mzero</code> and <code>mplus</code>. A monad is defined by providing instances for concrete data types. When monadic operations are used, the type inference system identifies the data type and selects the corresponding operations. From the client's point of view, a monad thus is defined by a type.<br><br>There are a few drawbacks of this setup:<br><ul><br>	<li>It is not possible to define a monad with a <code>zero</code> but no <code>plus</code>. This is a technical detail (<code>MonadPlus</code> could well be split into two typeclasses), but it's still a limitation in practical Haskell programming that is due to the rigidity of a type system.</li><br>	<li>It is impossible to have two monads for the same data type, although sometimes this would make sense. For example, there are (at least) two practically relevant ways to define <code>plus</code> for the list monad.</li><br>	<li>It is cumbersome to use the same monad operations for two different concrete data structures that are similar enough in behaviour to be used with the same monad definition.</li><br></ul><br>In Clojure, monads are values, not types. In client code, a monad is selected explicitly by the programmer by surrounding the monadic code by a <code>with-monad</code> form that specifies the monad to be used. Usually the monad is named explicitly, but since monads are values, they can also be represented by a variable. A Clojure monad can be used with any data type that the definitions of the monadic operations accept, and any number of monads can be defined for a data type.<br><br>In Clojure it is the data structure that almost disappears from monad handling; the constraints on the monadic values are given only as documentation for the human reader. As with other aspects of dynamic typing, this provides more flexibility and less protection.<br><br>For standard monads, I'd say that the clarity of code is roughly equivalent in Haskell and Clojure. Haskell gains a bit in making the data structure explicit, Clojure gains a bit in making the monad explicit at the point of use. Both work pretty well.<br><br>This changes when monad transformers come into play. In the Haskell world, this is perhaps the most frightening concept to newcomers. Monad transformers are surrounded by an aura of mystery, they are only for the real experts. I think that this is at least in part due to the complexity of defining monad transformers in a type system.<br><br>Here's how Haskell defines the list monad transformer; only the relevant parts are shown:<br><pre>newtype ListT m a = ListT { runListT :: m [a] }<br><br>instance (Monad m) =&gt; Monad (ListT m) where<br>    return a = ListT $ return [a]<br>    m &gt;&gt;= k  = ListT $ do<br>        a &lt;- runListT m<br>        b &lt;- mapM (runListT . k) a<br>        return (concat b)</pre><br>As in the case of abstract data types, there is a data type definition for <code>ListT</code> that does nothing but introduce a new notation for the type <code>m[a]</code>. <code>ListT</code> and <code>runListT</code> are just notation converters that don't actually do anything useful. But unlike in the case of abstract data types, they are indispensable here. Monads <em>are</em> types, and therefore there has to be a new type to make a new monad. It doesn't help that the name <code>runListT</code> is a particularly bad choice: it suggest an action where there is none.<br><br>The definitions of <code>return</code> and <code>&gt;&gt;=</code> aren't masterpieces of clarity either. It takes a careful analysis of each function and its (inferred, and thus unwritten) type to understand which monad is being used where.<br><br>For comparison, here is the corresponding monad transformer in Clojure, again reduced to the basics:<br><pre>(defn sequence-t [m]<br>   (monad<br>     [m-result (with-monad m<br>	         (fn [v]<br>		   (m-result (list v))))<br>      m-bind   (with-monad m<br>		 (fn [mv f]<br>                   (domonad<br>                     [a mv<br>                      b (m-map f a)]<br>		     (flatten b))))]))</pre><br>Since monads are values, monad transformers are simply functions that take a monad argument and return another monad. It is also clear at a glance that inside the definition of each monad operation, all references to monad operations are to be interpreted in the inner monad. This doesn't make monad transformers trivial to understand, of course, but it is a lot clearer.
