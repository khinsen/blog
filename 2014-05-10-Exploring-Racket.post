;;;;;
title: Exploring Racket
tags: Computational science, Programming
date: 2014-05-10 12:37:51
format: html
;;;;;
<p><br>Over the last few months I have been exploring the <a href="http://racket-lang.org/">Racket</a> language for its potential as a language for computational science, and it's time to summarize my first impressions.<br></p><br><br><h3 id="sec-1">Why Racket?</h2><br><p><br>There are essentially two reasons for learning a programing language: (1) getting acquainted with a new tool that promises to get some job done better than with other tools, and (2) learning about other approaches to computing and programming. My interest in Racket was driven by a combination of these two aspects. My background is in computational science (phsyics, chemistry, and structural biology), so I use computation extensively in my work. Like most computational scientists of my generation, I started working in Fortran, but quickly found this unsatisfactory. Looking for a better way to do computational science, I discovered <a href="http://www.python.org/">Python</a> in 1994 and joined the <a href="http://www.python.org/community/sigs/retired/matrix-sig/">Matrix-SIG</a> that developed what is now known as <a href="http://www.numpy.org/">NumPy</a>. Since then, Python has become my main programming language, and the ecosystem for scientific computing in Python has flourished to a degree unimaginable twenty years ago. For <i>doing</i> computational science, Python is one of the top choices today.<br></p><br><br><p><br>However, we shouldn't forget that we are still living in the stone age of computational science. Fortran was the Paleolithic, Python is the Neolithic, but we have to move on. I am convinced that computing will become as much an integral part of doing science as mathematics, but we are not there yet. One important aspect has not evolved since the beginnings of scientific computing in the 1950s: the work of a computational scientist is dominated by the technicalities of computing, rather than by the scientific concerns. We write, debug, optimize, and extend software, port it to new machines and operating systems, install messy software stacks, convert file formats, etc. These technical aspects, which are mostly unrelated to doing science, take so much of our time and attention that we think less and less about why we do a specific computation, how it fits into more general theoretical frameworks, how we can verify its soundness, and how we can improve the scientific models that underly our computations. Compare this to how theoreticians in a field like physics or chemistry use mathematics: they have acquired most of their knowledge and expertise in  mathematics during their studies, and spend much more time applying mathematics to do science than worrying about the intrinsic problems of mathematics. Computing should one day have the same role. For a more detailed description of what I am aiming at, see my recent <a href="http://f1000r.es/3af">article</a>.<br></p><br><br><p><br>This lengthy foreword was necessary to explain what I am looking for in Racket: not so much another language for doing today's computational science (Python is a better choice for that, if only for its well-developed ecosystem), but as an evironment for developing tomorrow's computational science. The Racket Web site opens with the title "A programmable programming language", and that is exactly the aspect of Racket that I am most interested in.<br></p><br><br><p><br>There are two more features of Racket that I found particularly attractive. First, it is one of the few languages that have good support for immutable data structures without being extremist about it. Mutable state is the most important cause of bugs in my experience (see my <a href="http://www.researchgate.net/publication/216857229_Managing_State/file/839957f7f612d58c02a6babe517f86ed.pdf">article on "Managing State"</a> for details), and I fully agree with Clojure's Rich Hickey who says that "immutability is the right default". Racket has all the basic data structures in a mutable and an immutable variant, which provides a nice environment to try "going immutable" in practice. Second, there is a statically typed dialect called <a href="http://docs.racket-lang.org/ts-guide/index.html">Typed Racket</a> which promises a straightforward transition from fast prototyping in plain Racket to type-safe and more efficient production code in Typed Racket. I haven't looked at this yet, so I won't say any more about it.<br></p><br><br><h3 id="sec-2">Racket characteristics</h2><br><p><br>For readers unfamiliar with Racket, I'll give a quick overview of the language. It's part of the <a href="http://en.wikipedia.org/wiki/Lisp_%2528programming_language%2529">Lisp</a> family, more precisely a derivative of <a href="http://en.wikipedia.org/wiki/Scheme_%2528programming_language%2529">Scheme</a>. In fact, Racket was formerly known as "PLT Scheme", but its authors decided that it had diverged sufficiently from Scheme to give it a different name. People familiar with Scheme will still recognize much of the language, but some changes are quite profound, such as the fact that lists are immutable. There are also many extensions not found in standard Scheme implementations.<br></p><br><br><p><br>The hallmark of the Lisp family is that programs are defined in terms of data structures rather than in terms of a text-based syntax. The most visible consequence is a rather peculiar visual aspect, which is dominated by parentheses. The more profound implication, and in fact the motivation for this uncommon choice, is the equivalence of code and data. Program execution in Lisp is nothing but interpretation of a data structure. It is possible, and common practice, to construct data structures programmatically and then evaluate them. The most frequent use of this characteristic is writing <i>macros</i> (which can be seen as code preprocessors) to effectively extend the language with new features. In that sense, all members of the Lisp family are "programmable programming languages".<br></p><br><br><p><br>However, Racket takes this approach to another level. Whereas traditional Lisp macros are small code preprocessors, Racket's macro system feels more like a programming API for the compiler. In fact, much of Racket is implemented in terms of Racket macros. Racket also provides a way to define a complete new language in terms of existing bits and pieces (see the paper "<a href="http://www.ccs.neu.edu/racket/pubs/pldi11-thacff.pdf">Languages as libraries</a>" for an in-depth discussion of this philosophy). Racket can be seen as a construction kit for languages that are by design interoperable, making it feasible to define highly specific languages for some application domain and yet use it in combination with a general-purpose language.<br></p><br><br><p><br>Another particularity of Racket is its origin: it is developed by a network of academic research groups, who use it as tool for their own research (much of which is related to programming languages), and as a medium for teaching. However, contrary to most programming languages developed in the academic world, Racket is developed for use in the "real world" as well. There is documentation, learning aids, development tools, and the members of the core development team are always ready to answer questions on the Racket user mailing list. This mixed academic-application strategy is of interest for both sides: researchers get feedback on the utility of their ideas and developments, and application programmers get quick access to new technology. I am aware of only three other languages developed in a similar context: <a href="http://caml.inria.fr/ocaml/">OCaml</a>, <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>, and <a href="http://www.scala-lang.org/">Scala</a>.<br></p><br><br><h3 id="sec-3">Learning and using Racket</h2><br><p><br>A first look at the <a href="http://docs.racket-lang.org/guide/index.html">Racket Guide</a> (an extended tutorial) and the <a href="http://docs.racket-lang.org/reference/index.html">Racket Reference</a> shows that Racket is not a small language: there is a bewildering variety of data types, control structures, abstraction techniques, program structuration methods, and so on. Racket is a very comprehensive language that allows both fine-tuning and large-scale composition. It definitely doesn't fit into the popular "low-level" vs. "high-level" dichotomy. For the experienced programmer, this is good news: whatever technique you know to be good for the task at hand is probably supported by Racket. For students of software development, it's probably easy to get lost. Racket comes with several subsets developed for pedagogical purposes, which are used in courses and textbooks, but I didn't look at those. What I describe here is the "standard" Racket language.<br></p><br><br><p><br>Racket comes with its own development environment called "DrRacket". It looks quite poweful, but I won't say more about it because I haven't used it much. I use too many languages to be interested in any language-specific environment. Instead, I use <a href="https://www.gnu.org/software/emacs/">Emacs</a> for everything, with <a href="http://www.nongnu.org/geiser/">Geiser</a> for Racket development.<br></p><br><br><p><br>The documentation is complete, precise, and well presented, including a pleasant visual layout. But it is not always an easy read. Be prepared to read through some background material before understanding all the details in the reference documentation of some function you are interested in. It can be frustrating sometimes, but I have never been disappointed: you do find everything you need to know if you just keep on following links.<br></p><br><br><p><br>My personal project for learning Racket is an <a href="https://github.com/mosaic-data-model/mosaic-racket">implementation</a> of the <a href="https://mosaic-data-model.github.io/">MOSAIC</a> data model for molecular simulations. While my implementation is not yet complete (it supports only two kinds of data items, universes and configurations), it has data structure definitions, I/O to and from XML, data validation code, and contains a test suite for everything. It uses some advanced Racket features such as generators and interfaces, not so much out of necessity but because I wanted to play with them.<br></p><br><br><p><br>Overall I had few surprises during my first Racket project. As I already said, finding what you need in the documentation takes a lot of time initially, mostly because there is so much to look at. But once you find the construct you are looking for, it does what you expect and often more. I remember only one ongoing source of frustration: the multitude of specialized data structures, which force you to make choices you often don't really care about, and to insert conversion functions when function A returns a data structure that isn't exactly the one that function B expects to get. As an illustration, consider the Racket equivalent of Python dictionaries, <a href="http://docs.racket-lang.org/guide/hash-tables.html">hash tables</a>. They come in a mutable and an immutable variant, each of which can use one of three different equality tests. It's certainly nice to have that flexibility when you need it, but when you don't, you don't want to have to read about all those details either.<br></p><br><br><p><br>As for Racket's warts, I ran into two of them. First, the worst supported data structure in Racket must be the <a href="http://docs.racket-lang.org/reference/vectors.html">immutable vector</a>, which is so frustrating to work with (every operation on an immutable vector returns a mutable vector, which has to be manually converted back to an immutable vector) that I ended up switching to lists instead, which are immutable by default. Second, the distinction (and obligatory conversion) between lists, streams, generators and a somewhat unclear sequence abstraction makes you long for the simplicity of a single sequence interface as found in Python or Clojure. In Racket, you can decompose a list into head and tail using <code>first</code> and <code>rest</code>. The same operations on a stream are <code>stream-first</code> and <code>stream-rest</code>. The sequence abstraction, which covers both lists and streams and more, has <code>sequence-tail</code> for the tail, but to the best of my knowledge nothing for getting the first element, other than the somewhat heavy <code>(for/first ([element sequence]) element)</code>.<br></p><br><br><p><br>The macro requirements of my first project were modest, not exceeding what any competent Lisp programmer would easily do using <code>defmacro</code> (which, BTW, exists in Racket for compatibility even though its use is discouraged). Nevertheless, in the spirit of my exploration, I tried all three levels of Racket's hygienic macro definitions: <code>syntax-rule</code>, <code>syntax-case</code>, and <code>syntax-parse</code>, in order of increasing power and complexity. The first, <code>syntax-rule</code> is straightforward but limited. The last one, <code>syntax-parse</code>, is the one you want for implementing industrial-strength compiler extensions. I don't quite see the need for the middle one, <code>syntax-case</code>, so I suppose it's there for historical reasons, being older than <code>syntax-parse</code>. Macros are the one aspect of Racket for which I recommend starting with something else than the Racket documentation: Greg Hendershott's <a href="http://www.greghendershott.com/fear-of-macros/">Fear of Macros</a> is a much more accessible introduction.<br></p><br><br><h3 id="sec-4">Scientific computing</h2><br><p><br>As I said in the beginning of this post, my goal in exploring Racket was not to use it for my day-to-day work in computational science, but nevertheless I had a look at the support for scientific computing that Racket offers. In summary, there isn't much, but what there is looks very good.<br></p><br><br><p><br>The basic Racket language has good support for numerical computation, much of which is inherited from Scheme. There are integers of arbitrary size, rational numbers, and floating-point numbers (single and double precision), all with the usual operations. There are also complex numbers whose real/imaginary parts can be exact (integer or rational) or inexact (floats). Unlimited-precision floats are provided by an interface to <a href="http://www.mpfr.org/">MPFR</a> in the Racket math library.<br></p><br><br><p><br>The <a href="http://docs.racket-lang.org/math/index.html">math library</a> (which is part of every standard Racket installation) offers many more goodies: multidimensional arrays, linear algebra, Fourier transforms, special functions, probability distributions, statistics, etc. The <a href="http://docs.racket-lang.org/plot/index.html">plot library</a>, also in the standard Racket installation, adds one of the nicest collections of plotting and visualization routines that I have seen in any language. If you use DrRacket, you can even rotate 3D scenes interactively, a feature that I found quite useful when I used (abused?) plots for molecular visualization.<br></p><br><br><p><br>Outside of the Racket distribution, the only library I could find for scientific applications is Doug Williams' "<a href="http://planet.racket-lang.org/display.ss?package%3Dscience.plt&amp;owner%3Dwilliams">science collection</a>", which predates the Racket math library. It looks quite good as well, but I didn't find an occasion yet for using it.<br></p><br><br><p><br>Could I do my current day-to-day computations with Racket? A better way to put it is, how much support code would I have to write that is readily available for more mature scientific languages such as Python? What I miss most is access to my data in HDF5 and netCDF formats. And the domain-specific code for molecular simulation, i.e. the equivalent of my own <a href="http://dirac.cnrs-orleans.fr/MMTK/">Molecular Modeling Toolkit</a>. Porting the latter to Racket would be doable (I wrote it myself, so I am familiar with all the algorithms and its pitfalls), and would in fact be an opportunity to improve many details. But interfacing HDF5 or netCDF sounds like a lot of work with no intrinsic interest, at least to me.<br></p><br><br><h3 id="sec-5">The community</h2><br><p><br>Racket has an apparently small but active, competent, and friendly community. I say "apparently" because all I have to base my judgement on is the Racket user mailing list. Given Racket's academic and teaching background, it is quite possible that there are lots of students using Racket who find sufficient support locally that they never manifest themselves on the mailing list. Asking a question on the mailing list almost certainly leads to a competent answer, sometimes from one of the core developers, many of whom are very present. There are clearly many Racket beginners (and also programming newbies) on the list, but compared to other programming language users' lists, there are very few naive questions and comments. It seems like people who get into Racket are serious about programming and are aware that problems they encounter are most probably due to their lack of experience rathen than caused by bugs or bad design in Racket.<br></p><br><br><p><br>I also noticed that the Racket community is mostly localized in North America, judging from the peak posting times on the mailing list. This looks strange in today's Internet-dominated world, but perhaps real-life ties still matter more than we think.<br></p><br><br><p><br>Even though the Racket community looks small compared to other languages I have used, it is big and healthy enough to ensure its existence for many years to come. Racket is not the kind of experimental language that is likely to disappear when its inventor moves on to the next project.<br></p><br><br><h3 id="sec-6">Conclusion</h2><br><p><br>Overall I am quite happy with Racket as a development language, though I have to add that I haven't used it for anything mission-critical yet. I plan to continue improving and completing my Racket implementation of Mosaic, and move it to Typed Racket as much as possible. But I am not ready to abandon Python as my workhorse for computational science, there are simply too many good libraries in the scientific Python ecosystem that are important for working efficiently.<br></p><br>
